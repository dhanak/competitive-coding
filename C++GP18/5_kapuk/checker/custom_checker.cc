// Start of BODY
#include <functional>

#define check(cond, v) do { if (!check_condition((cond), __FILE__, __LINE__, #cond)) return v; } while(0)

bool check_condition(bool cond, const char *file, int line, const char *conds)
{
    //if (!cond)
    //{
    //    cerr << "Condition '" << conds << "' failed at " << file << ':' << line << endl;
    //    cout << -1 << endl;
    //}
    return cond;
}

class gate_type
{
  public:
    using fn_t = function<bool(vector<bool> const &)>;
    fn_t fn;
    size_t min;
    size_t max;
    
    explicit gate_type(fn_t fn, size_t min = 1, size_t max = numeric_limits<size_t>::max()) : fn(fn), min(min), max(max) {}
    bool operator()(vector<bool> const &in) const { return fn(in); }
};

map<string, gate_type> const gate_types{
    {"NOT", gate_type([](vector<bool> const &in) { return !in[0]; }, 1, 1)},
    {"OR", gate_type([](vector<bool> const &in) { return any_of(in.begin(), in.end(), [](bool b) { return b; }); }, 2)},
    {"AND", gate_type([](vector<bool> const &in) { return all_of(in.begin(), in.end(), [](bool b) { return b; }); }, 2)},
    {"XOR", gate_type([](vector<bool> const &in) { return count(in.begin(), in.end(), 1) == 1; }, 2, 2)},
    {"NOR", gate_type([](vector<bool> const &in) { return !any_of(in.begin(), in.end(), [](bool b) { return b; }); }, 2)},
    {"NAND", gate_type([](vector<bool> const &in) { return !all_of(in.begin(), in.end(), [](bool b) { return b; }); }, 2)},
    {"NXOR", gate_type([](vector<bool> const &in) { return count(in.begin(), in.end(), 1) != 1; }, 2, 2)},
};

class circuit
{
  public:
    circuit(size_t n) : n(n), nodes(n) {}

    bool add_gate(gate_type const &gt, vector<size_t> const &in);
    bool calculate(vector<bool> const &in);
    bool operator[](size_t n) const { return nodes[n]; }

  protected:
    struct gate
    {
        gate_type const &gt;
        vector<size_t> in;
        size_t out;
    };

    size_t const n;
    vector<bool> nodes;
    vector<gate> gates;
};

bool circuit::add_gate(gate_type const &gt, vector<size_t> const &in)
{
    check(gt.min <= in.size() && in.size() <= gt.max, false);
    check(all_of(in.begin(), in.end(), [this](size_t n) { return n < nodes.size(); }), false);
    gates.push_back(gate{gt, in, nodes.size()});
    nodes.push_back(false);
    return true;
}

bool circuit::calculate(vector<bool> const &in)
{
    check(in.size() == n, false);
    for (size_t i = 0; i < n; ++i)
    {
        nodes[i] = in[i];
    }

    vector<bool> gin;
    for (gate const &g : gates)
    {
        gin.clear();
        gin.reserve(g.in.size());
        for (size_t i : g.in)
        {
            gin.push_back(nodes[i]);
        }
        nodes[g.out] = g.gt(gin);
    }
    return true;
}

int validate(string const infs, string const solfs)
{
    ifstream inf(infs);
    ifstream solf(solfs);
    if (!inf.is_open() || !solf.is_open())
    {
        return -1;
    }

    size_t K, L; // number of inputs and outputs
    inf >> K >> L;
    check(!inf.fail(), -1);

    int cost = 0;

    circuit c(K);
    size_t G; // number of gates
    vector<size_t> gin;
    solf >> G;
    check(!solf.fail(), -1);
    while (G-- > 0)
    {
        string gt;
        size_t nin;
        solf >> gt >> nin;
        check(!solf.fail(), -1);
        cost += nin + 1;
        gin.resize(nin);
        for (size_t i = 0; i < nin; ++i)
        {
            solf >> gin[i];
            check(!solf.fail(), -1);
            --gin[i];
        }
        auto igate = gate_types.find(gt);
        check(igate != gate_types.end(), -1);
        check(c.add_gate(igate->second, gin), -1);
    }

    vector<size_t> out(L);
    for (size_t l = 0; l < L; ++l)
    {
        solf >> out[l];
        check(!solf.fail(), -1);
        --out[l];
    }
    solf >> ws;
    check(!solf.fail() && solf.eof(), -1);

    size_t N;
    inf >> N;
    check(!inf.fail(), -1);
    vector<bool> in(K);
    while (N-- > 0)
    {
        string ins, outs;
        inf >> ins >> outs;
        check(!inf.fail(), -1);
        check(ins.size() == K && outs.size() == L, -1);
        for (size_t k = 0; k < K; ++k)
        {
            in[k] = ins[k] == '1';
        }
        c.calculate(in);
        for (size_t l = 0; l < L; ++l)
        {
            check(c[out[l]] == (outs[l] == '1'), -1);
        }
    }

    cerr << "Total cost of circuit: " << cost << endl;
    return cost;
}

/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  testcase_error_path           [string] File path to test-case STDERR
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  submission_language           [string] Language token of submission
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/


void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
    double max_score = 1000.0;
    int result = validate(t_obj.testcase_input_path, t_obj.testcase_output_path);
    ifstream(t_obj.testcase_expected_output_path) >> max_score;
    
    r_obj.result = result >= 0;
    r_obj.score = max((max_score - result) / max_score, 0.1);
    r_obj.message = result >= 0 ? "Success" : "Failure";
}
// End of BODY
