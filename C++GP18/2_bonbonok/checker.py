# Start of BODY
'''
TestStruct::
testcase_id                   [int] ID of the test-case
testcase_input_path           [str] File path to test-case input
testcase_output_path          [str] File path to test-case output generated by the problem solver
testcase_expected_output_path [str] File path to test-case expected output to be matched with
testcase_error_path           [str] File path to test-case STDERR
metadata_file_paths           [list<str>] File paths to Question metadata (Extra files usually used for defining traning sets)
submission_code_path          [str] File path to submission source code
submission_language           [str] Language token of submission
testcase_result               [bool] Set to True if test-case output matches test-case expected output. Matching is done line by line
testcase_signal               [int] Exit code of the test-case process
testcase_time                 [float] Time taken by the test-case process in seconds
testcase_memory               [int] Peak memory of the test-case process determined in bytes
data                          [str] <Future use>
ResultStruct::
result      [bool]  Assign test-case result. True determines success. False determines failure
score       [float] Assign test-case score. Normalized between 0 to 1
message     [str] Assign test-case message. This message is visible to the problem solver
'''

class Position:

    def __init__(self, x, y):
        self.x = x
        self.y = y


class Piece:

    # values: 2d array of values (0 means empty cell)
    def __init__(self, values):
        self.y = len(values)
        self.x = len(values[0])

        self.cells = values


class Board:

    def __init__(self, x, y, modulo, board):
        self.x = x
        self.y = y

        self.mod_value = modulo

        self.pieces = []
        self.positions = []

        self.board = board

    def use_piece(self, piece, x, y):
        assert(x >= 0)
        assert(x + piece.x <= self.x)
        assert(y >= 0)
        assert(y + piece.y <= self.y)

        for i in range(piece.y):
            for j in range(piece.x):
                self.board[y + i][x + j] += piece.cells[i][j]
                self.board[y + i][x + j] %= self.mod_value

    def get_min_score(self):
        return self.x * self.y * (self.mod_value - 1)

    def get_score(self):
        # first version: total score is the sum of remaining values
        score = sum([sum(values) for values in self.board])
        return score


def load_level_from_file(file_path):
    with open(file_path, "r") as file:
        lines = file.readlines()

    board_y, board_x, board_m = [int(i) for i in lines[0].split(' ')]

    board = [[] for _ in range(board_y)]
    for i in range(board_y):
        a = lines[i + 1].split()
        board[i] = [int(c) for c in lines[i + 1].split(' ')]

    num_of_pieces = int(lines[board_y + 1])

    pieces = []

    lineIndex = board_y + 2
    for i in range(num_of_pieces):
        piece_y, piece_x = [int(i) for i in lines[lineIndex].split(' ')]

        piece_array = [[0 for _ in range(piece_x)] for _ in range(piece_y)]
        for y in range(piece_y):
            piece_array[y] = [int(c) for c in lines[lineIndex + y + 1].split()]

        piece = Piece(piece_array)
        pieces.append(piece)

        lineIndex += piece_y + 1

    return Board(board_x, board_y, board_m, board), pieces


def load_solution_from_file(file_path):
    with open(file_path, "r") as file:
        lines = file.readlines()
    
    # filter out empty lines
    lines = [line.strip() for line in lines if line.strip()]
    
    positions = []
    
    for line in lines:
        y, x = [int(i) for i in line.split(' ')]
        positions.append(Position(x, y))
    return positions


def run_custom_checker(t_obj, r_obj):
    # Don't print anything to STDOUT in this function
    # Enter your custom checker scoring logic here

    try:
        board, pieces = load_level_from_file(t_obj.testcase_input_path)
    except Exception:
        r_obj.result = False;
        r_obj.score = 0.0;
        r_obj.message = "Loading testcase failed...";
        return
    
    try:
        solution = load_solution_from_file(t_obj.testcase_output_path)
    except Exception:
        r_obj.result = False;
        r_obj.score = 0.0;
        r_obj.message = "Loading solution failed...";
        return
    
    if len(solution) != len(pieces):
        r_obj.result = False;
        r_obj.score = 0.0;
        r_obj.message = "Invalid solution format...";
        return
    
    try:
        for i in range(len(pieces)):
            board.use_piece(pieces[i], solution[i].x, solution[i].y)
    except Exception:
        r_obj.result = False;
        r_obj.score = 0.0;
        r_obj.message = "Some of the pieces are out of bounds...";
    
    r_obj.result = True;
    r_obj.score = (board.get_min_score() - board.get_score()) / board.get_min_score();
    r_obj.message = "Success";

# End of BODY
